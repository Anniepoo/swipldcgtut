Markus' page
http://www.logic.at/prolog/dcg.html

1. Theory
1.1.1 Difference Lists

1.1.2 context free grammars

1.1.3 Panini - Backus- Naur Format

1.2  The prolog implementation

1.2.1 --> and term expansion
1.2.2 prolog escape 
1.2.3 Variables in the list
1.2.4 phrase/3

1.3 DCG's for other than parsing input

the 'valid airplane activity data' problem
(I have a running implementation of tale-spin. I was going to use it to generate a bunch of airplane flight event data, of form load_passengers, push_back, taxi, take_off, climb, cruise, etc. Then have students check the list)


2. Practice
2.1. Advice for specific situations
2.1.2 end of file

2.2 Handy built in functions

basics.pl
stats
odd_even
csv
html
page

2.3 Handy Tricks

...

using listing

Markus' tricks

2.4. Lexical issues

2.4.1 Representation

codes, 1 char atoms, tokens, tokens with location and attributes

2.4.2 To lex before parsing?

Handling comments

Handling inclusion


2.5.  Handling Errors In Input

Detecting Errors

Finding position in input.

Examining the remainder.

inserting clue tokens in the input stream

line and char counting

using phrase_from_file

6. Semantics



===================================


difference lists

context free grammars

backus naur format

The prolog implementation

phrase

Reading in text
phrase_from_file  (pure input)

Reading from user or stream
wait_for_input(+ListOfStreams, -ReadyList, +TimeOut)


showing line numbers
line_count
line_position

if you can't use parse_from_file
read and insert
line(LineNumber, String)

often saying what the chain of nonterminals is is more useful.
(could that be automated by examining stack?)

research:s
Swipl docs
Craft of Prolog
Clocksin/Mellish
Amzi
http://www.amzi.com/manuals/amzi/pro/ref_dcg.htm


stats
odd_even


csv

html
page


basics.pl



common situations -

handling errors
   -  by segmenting the parse
   -  by completing the language


DCG's for other than parsing input

the 'valid airplane activity data' problem

Learn Prolog Now discusses the role of extra arguments

http://www.learnprolognow.org/lpnpage.php?pagetype=html&pageid=lpn-htmlse32


ambiguous grammar

http://stackoverflow.com/questions/6035451/what-is-an-ambiguous-context-free-grammar?rq=1

================================

On 08/31/2012 09:15 AM, Carlo Capelli wrote:
> Hi Anne
>
> Tracking position in a DCG can be simple: p//0 it's a service 'production'
> just to access hidden arguments
>
> x --> p, "a", x ; "".
> p(L, L) :- format('~s~n', [L]).
>
> ?- phrase(x, "aaa").
> aaa
> aa
> a
>
> HTH, but maybe I don't understand your question.

Roughly, the typical way is (AFAIK), to pick the remainder and
either say "error XYZ before "some tokens"" or you use the remainder
with whatever info you have to work out the location.  Would be nice
to have some ready-to-use code for a couple of typical cases, such
as phrase_from_file and cases where the input is a code-list.

A remaining problem is that many parsers use two levels of DCG: one to
tokenize and one to do the remainder.  Printing `before ...' still works,
but line/column gets harder.

    Cheers --- Jan

=============

Hi Anne,

Anne Ogborn <annie66us@yahoo.com> writes:

> date_time -->
>       {
>          get_time(Stamp),
>          stamp_date_time(Stamp, DT, local),
>          format_time(codes(DateTime), '%a, %e %b %Y %T %z (%Z)', DT)
>       },
>       "Date: ",
>       match_me(DateTime),
>       "\n".
>
> match_me(Codes, Out, Rest) :-
>       append(Codes, Rest, Out).
>
> is 'match me' needed here?


It is best not to rely on a particular expansion method for DCGs, such
as the order of additional arguments. If you want to refer to the
difference list arguments from within regular predicates, using the
nonterminal call//1 will keep your code portable, as a future ISO
standard for DCGs will hopefully provide this construct, and best of all
it already works with the usual DCG expansion method, resulting in a
call of call/3 with the intended argument order. So, if you want to use
match_me at all, it is best to change the predicate call

   match_me(DateTime)

to:

   call(match_me(DateTime))

That being said, there is indeed no need for match_me/3. To see what
term_expansion does with a variable, change the definition to:

   date_time -->
    {
       get_time(Stamp),
       stamp_date_time(Stamp, DT, local),
       format_time(codes(DateTime), '%a, %e %b %Y %T %z (%Z)', DT)
    },
    "Date: ",
    DateTime,
    "\n".

and try listing/1:

   ?- listing(date_time//0).
   date_time(C, H) :-
          get_time(A),
          stamp_date_time(A, B, local),
          format_time(codes(E), '%a, %e %b %Y %T %z (%Z)', B),
          D=C,
          D=[68, 97, 116, 101, 58, 32|F],
          phrase(E, F, G),
          G=[10|H].

You see that the variable is expanded to a phrase/3 call. When the call
is executed, E is a list of character codes which are then appended.

Finally, consider the following auxiliary definitions:

   format_time_(Fs, Args) --> call(format_time__(Fs, Args)).

   format_time__(Fs, Args, Xs0, Xs) :- format_time(codes(Xs0,Xs), Fs, Args).

This gives you a "DCG version" of format_time/3 that appends the
string it generates in a DCG context. You can now write your code as:

   date_time -->
       { get_time(Stamp), stamp_date_time(Stamp, DT, local) },
       format_time_('Date: %a, %e %b %Y %T %z (%Z)\n', DT).


You may also find a DCG version of format/2 useful:

   format_(Fs, Args) --> call(format__(Fs, Args)).

   format__(Fs, Args, Xs0, Xs) :- format(codes(Xs0,Xs), Fs, Args).

Example:

   ?- phrase(format_("test: ~w\n", [X]), Ls), format("~s", [Ls]).
   %@ test: _G249
   %@ Ls = [116, 101, 115, 116, 58, 32, 95, 71, 50|...].


All the best,
Markus


=========

Annie sez
a note about this


send_to(Email) -->
	"\nTo: ",
        Email,
	"\n".

from UH code
send_to('annie66us@yahoo.com')

produces a CALL to that as a pred!

5 ?- phrase(mail:send_to(blah), X).
ERROR: phrase/3: Undefined procedure: mail:blah/2
6 ?- phrase(mail:send_to("blah"), X).
X = [10, 84, 111, 58, 32, 98, 108, 97, 104|...].

8 ?- phrase(mail:send_to(3), X),format('~s~n', [X]).
ERROR: phrase/3: Type error: `callable' expected, found `3'


you can use a term or a list

foo --> a, B, c.

